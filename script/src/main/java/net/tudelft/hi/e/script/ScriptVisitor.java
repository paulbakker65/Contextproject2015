package net.tudelft.hi.e.script;

import net.tudelft.hi.e.common.enums.ChunkType;
import net.tudelft.hi.e.common.enums.ComputeOperator;
import net.tudelft.hi.e.common.exceptions.ExceptionHandler;
import net.tudelft.hi.e.common.exceptions.TableNotFoundException;
import net.tudelft.hi.e.computation.BetweenOperation;
import net.tudelft.hi.e.computation.ChunkingOperation;
import net.tudelft.hi.e.computation.CodingOperation;
import net.tudelft.hi.e.computation.CombineOperation;
import net.tudelft.hi.e.computation.ComputeOperation;
import net.tudelft.hi.e.computation.Condition;
import net.tudelft.hi.e.computation.ConnectionOperation;
import net.tudelft.hi.e.computation.ConstraintOperation;
import net.tudelft.hi.e.computation.ForEachChunkOperation;
import net.tudelft.hi.e.computation.LsaOperation;
import net.tudelft.hi.e.computation.Operation;
import net.tudelft.hi.e.computation.Pattern;
import net.tudelft.hi.e.computation.PatternDescription;
import net.tudelft.hi.e.computation.PatternFactory;
import net.tudelft.hi.e.data.NumberValue;
import net.tudelft.hi.e.data.Table;
import net.tudelft.hi.e.data.Value;
import net.tudelft.hi.e.script.AnalysisLangParser.Between_operationContext;
import net.tudelft.hi.e.script.AnalysisLangParser.Between_paramContext;
import net.tudelft.hi.e.script.AnalysisLangParser.Chunk_operationContext;
import net.tudelft.hi.e.script.AnalysisLangParser.Constraint_operationContext;
import net.tudelft.hi.e.script.AnalysisLangParser.Pattern_descriptionContext;
import net.tudelft.hi.e.script.AnalysisLangParser.Pattern_description_recContext;

import org.antlr.v4.runtime.tree.AbstractParseTreeVisitor;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;

/**
 * Script visitor class that visits each node of the parse thee instead of listening to a
 * treewalkers findings.
 */
class ScriptVisitor extends AbstractParseTreeVisitor implements AnalysisLangVisitor {

  private static final Logger LOG = Logger.getLogger(ScriptVisitor.class.getName());

  /**
   * List of tables containing all the tables available for input data.
   */
  private final List<Table> tables;

  /**
   * List of Operations where all the parsed operations will be stored.
   */
  private final List<Operation> operationList;

  /**
   * Default constructor for creating a script visitor.
   *
   * @param tableList
   *         the list of tables that it can use as input for operations.
   */
  public ScriptVisitor(final List<Table> tableList) {
    super();
    this.tables = tableList;
    this.operationList = new ArrayList<>();
    String temp = LOG.getName();
    ExceptionHandler.replaceHandler(LOG);
    LOG.setUseParentHandlers(false);
  }

  /**
   * Creates a list of operations walking a parsetree generated by the analysisparser.
   *
   * @return the list of operations the visitor created.
   */
  public List<Operation> getOperationList() {
    return this.operationList;
  }

  /**
   * The getTableForTableName method retrieves the Table with the specified table name from the list
   * of Tables in the tables field.
   *
   * @param tableName
   *         The table name that is searched for.
   *
   * @return The Table object retrieved from tables.
   *
   * @throws TableNotFoundException
   *         If the the table cannot be found in the tables field a TableNotFoundException is
   *         thrown.
   */
  private Table getTableForTableName(final String tableName) throws TableNotFoundException {
    for (final Table table : this.tables) {
      if (table.getName().equals(tableName)) {
        return table;
      }
    }
    throw new TableNotFoundException(String.format("Table \"%s\" not found", tableName));
  }

  @Override
  public final BetweenOperation visitBetween_operation(final Between_operationContext ctx) {
    return visitBetween_param(ctx.param);
  }

  @Override
  public final BetweenOperation visitBetween_param(final Between_paramContext ctx) {
    BetweenOperation betweenOperation = null;
    try {
      betweenOperation =
              new BetweenOperation(this.getTableForTableName(visitField(ctx.eventcol)[0]),
                      visitField(ctx.eventcol)[1], visitField(ctx.datecol1)[1],
                      visitField(ctx.datecol2)[1], visitValue(ctx.value1), visitValue(ctx.value2));
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return betweenOperation;
  }

  @Override
  public final Object visitCalc_operator(final AnalysisLangParser.Calc_operatorContext ctx) {
    return ctx.op;
  }

  @Override
  public final ChunkingOperation visitChunk_operation(final Chunk_operationContext ctx) {
    return visitChunk_param(ctx.param);
  }

  @Override
  public final ChunkingOperation visitChunk_param(final AnalysisLangParser.Chunk_paramContext ctx) {
    ChunkingOperation chunkingOperation = null;
    try {
      chunkingOperation =
              new ChunkingOperation(this.getTableForTableName(visitField(ctx.fieldparam)[0]),
                      visitField(ctx.fieldparam)[1], visitChunk_type(ctx.type),
                      (int) ((NumberValue) visitNumber(ctx.numberparam)).getValue());
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return chunkingOperation;
  }

  @Override
  public final ChunkType visitChunk_type(final AnalysisLangParser.Chunk_typeContext ctx) {
    return ctx.op;
  }

  @Override
  public final Object visitCode_operation(final AnalysisLangParser.Code_operationContext ctx) {
    return visitCode_param(ctx.param);
  }

  @Override
  public final CodingOperation visitCode_param(final AnalysisLangParser.Code_paramContext ctx) {
    CodingOperation codingOperation = null;
    try {
      codingOperation = new CodingOperation(this.getTableForTableName(visitTable(ctx.tableparam)),
              visitPattern(ctx.patternparam), visitText(ctx.codenameparam).toString());
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return codingOperation;
  }

  @Override
  public final Object visitCompare_operator(final AnalysisLangParser.Compare_operatorContext ctx) {
    return ctx.op;
  }

  @Override
  public final ComputeOperation visitCompute_operation(
          final AnalysisLangParser.Compute_operationContext ctx) {
    return visitCompute_param(ctx.param);
  }

  @Override
  public final ComputeOperator visitCompute_operator(
          final AnalysisLangParser.Compute_operatorContext ctx) {
    return ctx.op;
  }

  @Override
  public final ComputeOperation visitCompute_param(
          final AnalysisLangParser.Compute_paramContext ctx) {
    ComputeOperation computeOperation = null;
    try {
      computeOperation = new ComputeOperation(this.getTableForTableName(visitTable(ctx.tableparam)),
              this.visitCompute_operator(ctx.computeopparam), visitField(ctx.fieldparam)[1]);
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return computeOperation;
  }

  @Override
  public final List<Condition> visitCondition(final AnalysisLangParser.ConditionContext ctx) {
    final List<Condition> resultConditionList = new ArrayList<>();
    resultConditionList.add(ctx.cond);
    if (ctx.anothercond != null) {
      resultConditionList.addAll(this.visitCondition(ctx.anothercond));
    }
    return resultConditionList;
  }

  @Override
  public final ConnectionOperation visitConnect_operation(
          final AnalysisLangParser.Connect_operationContext ctx) {
    return visitConnect_param(ctx.param);
  }

  @Override
  public CombineOperation visitCombine_operation(
          final AnalysisLangParser.Combine_operationContext ctx) {
    return visitCombine_param(ctx.param);
  }

  @Override
  public final ConnectionOperation visitConnect_param(
          final AnalysisLangParser.Connect_paramContext ctx) {
    ConnectionOperation connectionOperation = null;
    try {
      final String[] firstField = visitField(ctx.fieldparam);
      final String[] secondField = visitField(ctx.anotherfieldparam);
      connectionOperation = new ConnectionOperation(this.getTableForTableName(firstField[0]),
              this.getTableForTableName(secondField[0]), firstField[1], secondField[1]);
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return connectionOperation;
  }

  @Override
  public CombineOperation visitCombine_param(final AnalysisLangParser.Combine_paramContext ctx) {
    CombineOperation combineOperation = null;
    try {
      final String[] firstField = visitField(ctx.fieldparam);
      final String[] secondField = visitField(ctx.anotherfieldparam);
      combineOperation = new CombineOperation(this.getTableForTableName(firstField[0]),
              this.getTableForTableName(secondField[0]), firstField[1], secondField[1]);
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return combineOperation;
  }

  @Override
  public final ConstraintOperation visitConstraint_operation(
          final Constraint_operationContext ctx) {
    return visitConstraint_param(ctx.param);
  }

  @Override
  public final ConstraintOperation visitConstraint_param(
          final AnalysisLangParser.Constraint_paramContext ctx) {
    ConstraintOperation constraintOperation = null;
    try {
      constraintOperation =
              new ConstraintOperation(this.getTableForTableName(visitField(ctx.fieldparam)[0]),
                      visitField(ctx.fieldparam)[1], ctx.opparam.op, visitValue(ctx.valueparam));
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return constraintOperation;
  }

  @Override
  public final Object visitCount_pattern(final AnalysisLangParser.Count_patternContext ctx) {
    return ctx.count;
  }

  @Override
  public final Value visitDate(final AnalysisLangParser.DateContext ctx) {
    return ctx.val;
  }

  @Override
  public final String[] visitField(final AnalysisLangParser.FieldContext ctx) {
    return new String[]{ctx.tablename, ctx.fieldname};
  }

  @Override
  public final Object visitForeach_chunk_operation(
          final AnalysisLangParser.Foreach_chunk_operationContext ctx) {
    return visitForeach_chunk_param(ctx.param);
  }

  @Override
  public final ForEachChunkOperation visitForeach_chunk_param(
          final AnalysisLangParser.Foreach_chunk_paramContext ctx) {
    ForEachChunkOperation forEachChunkOperation = null;
    try {
      forEachChunkOperation =
              new ForEachChunkOperation(this.getTableForTableName(visitTable(ctx.tableparam)),
                      visitNumberGetInt(ctx.levelparam), visitOperationNoAdd(ctx.operationparam));
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return forEachChunkOperation;
  }

  @Override
  public final LsaOperation visitLsa_operation(final AnalysisLangParser.Lsa_operationContext ctx) {
    return visitLsa_param(ctx.param);
  }

  @Override
  public final LsaOperation visitLsa_param(final AnalysisLangParser.Lsa_paramContext ctx) {
    LsaOperation lsaOperation = null;
    try {
      final String[] fieldReference = this.visitField(ctx.fieldparam);
      lsaOperation =
              new LsaOperation(this.getTableForTableName(fieldReference[0]), fieldReference[1],
                      visitNumberGetInt(ctx.from), visitNumberGetInt(ctx.to), visitValue(ctx.key),
                      visitValue(ctx.target));
    } catch (TableNotFoundException ex) {
      LOG.log(Level.SEVERE, ex.getMessage(), ex);
    }
    return lsaOperation;
  }

  @Override
  public final Value visitNumber(final AnalysisLangParser.NumberContext ctx) {
    return ctx.val;
  }

  /**
   * Visit a Number Node in the parse tree and turn it into a number instead of a NumberValue.
   *
   * @param ctx
   *         The NumberContext Node.
   *
   * @return an integer representation of the number context.
   */
  private int visitNumberGetInt(final AnalysisLangParser.NumberContext ctx) {
    final NumberValue val = (NumberValue) ctx.val;
    return (int) val.getValue();
  }

  @Override
  public final Operation visitOperation(final AnalysisLangParser.OperationContext ctx) {
    this.operationList.add((Operation) visitChildren(ctx));
    return this.operationList.get(this.operationList.size() - 1);
  }

  /**
   * Visit an Operation Node without adding the resulting operation to the operationList. This
   * method is used to visit operations that are children of a {@see ForEachChunkOperation} to
   * prevent those operations from also being added to the list of generic operations.
   *
   * @param ctx
   *         The OperationContext to visit.
   *
   * @return An Operation that was defined by the subtree.
   */
  private Operation visitOperationNoAdd(final AnalysisLangParser.OperationContext ctx) {
    return (Operation) visitChildren(ctx);
  }

  @Override
  public final Object visitParse(final AnalysisLangParser.ParseContext ctx) {
    visitChildren(ctx);
    return this.operationList;
  }

  @Override
  public final Pattern visitPattern(final AnalysisLangParser.PatternContext ctx) {
    return PatternFactory.createPattern(ctx.patterndesc);
  }

  @Override
  public final Object visitRecord_condition(final AnalysisLangParser.Record_conditionContext ctx) {
    return ctx.recordcondition;
  }

  @Override
  public final String visitTable(final AnalysisLangParser.TableContext ctx) {
    return ctx.tablename;
  }

  @Override
  public final Value visitText(final AnalysisLangParser.TextContext ctx) {
    return ctx.val;
  }

  @Override
  public final Value visitValue(final AnalysisLangParser.ValueContext ctx) {
    return ctx.val;
  }

  @Override
  public final PatternDescription visitPattern_description(Pattern_descriptionContext ctx) {
    return ctx.description;
  }

  @Override
  public final PatternDescription visitPattern_description_rec(Pattern_description_recContext ctx) {
    return ctx.description_rec;
  }

}
